coins = [25, 10, 1]
V = 30

'''
니켈이 없는 경우의 시나리오:
니켈(5 센트)이 동전에서 제외된 경우, 알고리즘은 최적이 아닐 수 있습니다. 예를 들어, V가 30 센트인 경우를 생각해 봅시다:

1 개의 쿼터(25 센트)를 사용하고 남은 금액은 5 센트입니다.
니켈이 없으므로 남은 5 센트를 만들기 위해 5 개의 페니를 사용할 것입니다.
결과적으로 알고리즘은 [1, 0, 5]를 반환하며, 1 개의 쿼터, 0 개의 다임, 5 개의 페니를 나타냅니다. 그러나 최적해는 3 개의 다임을 사용하는 것으로, [0, 3, 0]이 됩니다.

종합적으로, 탐욕 알고리즘의 최적성은 특정 동전 액면가에 따라 다릅니다. 동전 액면가가 특정한 관계를 가질 경우에만 탐욕 알고리즘이 최적해를 제공할 수 있습니다. 그렇지 않은 경우 항상 최적이 아닐 수 있습니다.
'''

'''
https://velog.io/@hanni66/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
모든 동전의 액면이 바로 아래 액면의 배수가 되면 그리디 알고리즘으로 최적해가 보장된다.
교과서) 동전의 액면가 중에서 어떤 두 개를 고르더라도 큰 액면가를 작은 액면가로 나누어 떨어지는
동전 체계를 갖는다면 최적해를 보장한다. 작은 액면가를 여러 개 모으면 반드시 큰 액면가를 만들 수 있기 때문이다.

예) 500원, 100원, 50원, 10원, 5원, 1원
그리디 알고리즘으로 최적해가 보장되지 않는 예
예) 500원, 400원, 100원, 75원, 50원
'''

def min_coins_greedy(V, coins):
    cnt = []
    for i in range(len(coins)):
        j = V // coins[i]
        cnt.append(j)
        V -= coins[i] * j
    return cnt

print(min_coins_greedy(V, coins))